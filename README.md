# LearningAlgo

파이썬 문법 알고리즘 저장소

### 알고리즘 문제 풀이 접근법 총정리

---

**1. 전체 접근 순서**

```
문제 이해 → 제약 조건 분석 → 자료구조 선택 → 알고리즘 설계 → 코드 작성 → 검증
```

---

**2. 문제 이해**

- 입력/출력 형식 확인
- **제약 조건(constraints)** 반드시 확인
- 엣지 케이스 미리 파악
  - 빈 배열, 음수, 중복값, 최솟값/최댓값 경계 등

---

**3. 제약 조건으로 복잡도 역산**

n 크기를 보고 허용 가능한 시간 복잡도를 먼저 파악한다.

| n 크기 | 허용 복잡도 |
|---|---|
| n ≤ 10 | O(n!) 까지 가능 |
| n ≤ 20~25 | O(2^n) |
| n ≤ 500 | O(n³) |
| n ≤ 5,000 | O(n²) |
| n ≤ 10^6 | O(n log n) |
| n ≤ 10^8 | O(n) |
| n > 10^8 | O(log n), O(1) |

> 복잡도를 "암기"하기보다, **왜 그 복잡도가 나오는지 설명할 수 있는 것**이 핵심.

---

**4. 자료구조 선택**

**판단 기준: "어떤 연산이 자주 발생하는가?"**

> 데이터가 무엇인지보다 **연산 패턴**을 먼저 파악한다.

| 필요한 연산 | 자료구조 |
|---|---|
| 빠른 조회 / 중복 제거 | HashMap, HashSet |
| 정렬 상태 유지 + 탐색 | BST, TreeMap |
| 최솟값 / 최댓값 반복 추출 | Heap (Priority Queue) |
| 순서 있는 삽입 / 삭제 | LinkedList, Deque |
| 구간 합 / 범위 쿼리 | Segment Tree, BIT (Fenwick Tree) |
| 계층 관계 / 경로 탐색 | Tree, Graph |
| LIFO | Stack |
| FIFO | Queue |

**자료구조 선택 3단계**

1. **접근 패턴 파악** — 탐색이 많다 → 해시 / 우선순위 필요 → 힙 / 범위 쿼리 → 세그먼트 트리
2. **트레이드오프 인식** — HashMap은 조회 O(1)이지만 정렬 순회가 필요하면 TreeMap
3. **공간 복잡도 체크** — 최적화하려다 메모리 초과 주의, 특히 n이 클 때

---

**5. 알고리즘 설계**

**브루트포스 → 최적화 순서**

1. 가장 단순한 해법(브루트포스)을 먼저 떠올린다
2. "어디서 중복 연산이 발생하나?" 를 찾는다
3. 중복 제거 방법을 적용한다 (메모이제이션, 슬라이딩 윈도우 등)

**알고리즘 패턴 매칭**

| 패턴 | 적용 상황 |
|---|---|
| 슬라이딩 윈도우 | 연속 구간, 고정/가변 길이 부분 배열 |
| 투 포인터 | 정렬된 배열, 합/조건 만족하는 쌍 찾기 |
| BFS / DFS | 그래프 탐색, 최단 경로, 연결 요소 |
| DP | 중복 부분 문제, 최적 부분 구조 |
| 분할 정복 | 재귀적으로 나눌 수 있는 문제 |
| 그리디 | 매 순간 최선이 전체 최선인 경우 |
| 이진 탐색 | 정렬된 데이터, 범위를 반씩 좁힐 수 있는 경우 |
| 백트래킹 | 조합/순열, 가지치기 가능한 탐색 |

---

**6. 코드 작성 전 검증**

- 의사코드 또는 그림으로 먼저 로직 검증
- DP라면 **점화식을 먼저 명확히** 정의
- 인터뷰에서는 말로 설명하면서 진행 → 복잡도 분석도 같이 설명

---

**7. 코드 작성 후 테스트**

- 기본 케이스
- 엣지 케이스 (빈 입력, 경계값, 중복)
- 큰 입력에서 시간/메모리 초과 여부 예측

---

**요약 플로우**

```
1. 문제 읽기          → 입출력, 제약 조건, 엣지 케이스 파악
2. 복잡도 역산        → n 크기 보고 허용 복잡도 결정
3. 연산 패턴 파악     → 어떤 연산이 자주 발생하는가?
4. 자료구조 선택      → 연산 패턴에 맞는 자료구조
5. 알고리즘 패턴 매칭 → 브루트포스 → 최적화
6. 로직 검증          → 의사코드, 점화식
7. 코드 작성          → 엣지 케이스 테스트
```